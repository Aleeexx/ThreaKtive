import Image from "next/image"

# Continuation API [^1] [^2] [^3]

Einen wichtigen Part hat das spezielle Objekt `Continuation` mit deren Methoden für die Umsetzung
und der Verwaltung der virtuellen Threads. Aus der Sicht eines Entwicklers wird dieser mit dem Objekt
keine direkten Berührungspunkte haben, diese werden „unter der Haube“ ausgeführt, in der produktiven
Entwicklung wird es nicht verwendet. Eine wichtige Änderung ist das pro Aufgabe ein virtueller Thread
gestartet wird und nicht mehr, wie bei den Platform Threads, wo ein Executor Service eine bestimmte
Anzahl von Platform Threads hatte und diese nach und nach die anstehenden Aufgaben abzuarbeiten.
Eine Aufgabe auf einem virtuellen Thread wird gestartet, indem die Methode `run` auf dem Objekt
`Continuation` ausgeführt wird. Um den weiteren Ablauf besser zu verstehen, hilft Abbildung x.
Ein virtueller Thread wird auf einem Platform Thread (auch genannt `Carrier Thread`) ausgeführt.
Es gibt drei verschiedene Zustände von einem virtuellen Thread. Der erste Zustand ist der `"mounted"`,
der virtuelle Thread wird auf dem Platform Thread ausgeführt. Der zweite Zustand ist der `"unmounted blocked"`,
die Aufgabe des virtuellen Threads führt einen blockierenden Aufruf aus und wartet auf eine Antwort.
Der letzte Zustand ist der `"unmounted ready"`, der blockierende Aufruf der Aufgabe hat die Antwort zurückerhalten.
Zudem wurden alle wichtigen Informationen aus dem Heap Speicher geladen und die Aufgabe ist bereit weiter ausgeführt zu werden.

<div className="box-center" style={{ width: "430px", height: "475" }}>
  <Image
    sizes="100vw"
    style={{
        width: '100%',
        height: 'auto',
      }}
    width={430}
    height={475}
    src="/images/os_vt_handling.png"
    alt="Betriebssystem Handling mit Virtual Threads"

/>

  <span className="source text-center">Abbildung X - Quelle: https://jenkov.com/tutorials/java-concurrency/java-virtual-threads.html</span>
</div>

Wenn die Aufgabe ausgeführt wird (nachdem die Methode run ausgeführt wurde) und einen blockierenden Aufruf ausgeführt hat
und auf dessen Antwort wartet, wird auf dem Object `Continuation` die Methode `yield()` aufgerufen.
In diesem Schritt werden die Daten aus dem Stack (Informationen zu der aktuellen Aufgabe, Quellcode und
deren Ausführungsstand etc.) in dem Heap-Speicher persistiert und der virtuelle Thread wird vom Platform Thread
gelöst (`Unmounting`) und befindet sich nun in der Queue `"unmounted blocked"`. Dort wartet der virtuelle Threads so lange,
bis ein Trigger ausgelöst wird, dass die Antwort von dem blockierenden Aufruf vorhanden ist.
Der Trigger löst die Methode `run()` vom Objekt `Continuation` aus und dann wird der Stack vom virtuellen Thread aus dem Heap geladen.
Nach dieser Prozedur wird der virtuelle Thread in die Queue `"unmounted ready"` verschoben.
Das ist der Kreislauf der virtuellen Threads, dieser wird von der JVM verwaltet. Das ist ein erheblicher Vorteil
gegenüber den Platform Threads, dieser werden vom Betriebssytem verwaltet. Wenn ein Platform Thread erstellt werden soll,
muss ein Systemaufruf ans Betriebssystem gestellt werden. Dieser Aufruf ist sehr kostenintensiv, das fällt beim virtuellen Thread weg.  
Das Objekt `Continuation` ist in einer Low-Level-API die von einem Entwickler standardmäßig nicht verwendet wird,
diese kann aber wie in Abbildung x zum Experimentieren und besserem verstehen verwendet werden.

<div className="box-center" style={{ width: "430px", height: "310" }}>
  <Image
    className="centered-image"
    width="430"
    height="310"
    src="/images/continuation-example.png"
    alt="Beispielhafte Verwendung der Continuation API"
  />
  <span className="source text-center">Abbildung X - Quelle: Eigene Anfertigung</span>
</div>

Das Beispiel kann für Einsteiger von virtuellen Threads einen Moment dauern, bis dieses Beispiel verstanden wird.
Die Ausgabe von diesem Code sieht so aus:

```
Start run()
Start C1
End run()
Start run()
End C1
End run()
```

In der `while`-Schleife wird zuerst das `"Start run()"` ausgegeben, danach wird die Methode `run()` des `Continuation`
Objekts ausgeführt. Aus diesem Grund wird dann `"Start C12"` ausgegeben. Anschließend wird die Methode `yield()`
des `Continuation` Objekts ausgeführt und es wird angehalten. Die `while`-Schleife wird deshalb
weiter ausgeführt und es wird gewartet bis die Methode `run()` wieder auf dem `Continuation` Objekt aufgerufen
wird. In dieser Zeit wird `"End run()"` und `"Start run()"` ausgegeben. Danach wird die Variable `c` an der
Stelle fortgesetzt, an welcher diese pausiert wurde. Die Ausgabe ist `"End C1"`. Abschließend wird die
`while`-Schleife `"End run()"` ausgeben und beendet, weil das `Continuation` Objekt komplett ausgeführt wurde.
Dieses Vorgehen ist die Art und Weise, wie blockierende Operationen von der JVM verarbeitet werden.

Ein direkter Vergleich zwischen Platform Threads und virtuellen Threads ist hier: zu sehen. Hier wird auch der zeitliche Faktor betrachtet.
Eine Analogie um den Unterschied zwischen Platform Threads und Virtuellen Threads besser zu verstehen, ist in diesem Tutorial zu sehen.

<iframe
  className="box-center"
  width="560"
  height="315"
  src="https://www.youtube-nocookie.com/embed/moWtPS_PwU0?si=58ZXiZdZyg5y6T6N"
  title="YouTube video player"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
  allowFullScreen
></iframe>

[^1]: Siehe https://www.happycoders.eu/de/java/virtual-threads/
[^2]: Siehe https://www.youtube.com/watch?v=5E0LU85EnTI
[^3]: Siehe https://www.baeldung.com/java-virtual-thread-vs-thread
