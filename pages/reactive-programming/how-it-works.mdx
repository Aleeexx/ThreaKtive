---
authorName: Carla Hugenroth
authorGithubName: hrothc
---

# Schlüsselkonzepte [^1] [^2] [^3] [^4] [^5] [^6] [^7] [^8] [^9]

## Publisher und Subscriber

In der reaktiven Programmierung gibt es einen `Publisher`, der Datenstrom erzeugt, und `Subscriber`, die auf diese Daten reagieren.
Der `Publisher` sendet Daten, und `Subscriber` verarbeiten sie asynchron.

## Flux und Mono

Reactor stellt zwei Haupttypen von `Publishern` bereit: `Flux` für einen Datenstrom von 0 bis n Elementen und `Mono`
für einen Datenstrom von 0 bis 1 Element. Diese Typen können kombiniert und transformiert werden,
um komplexe reaktive Abläufe zu erstellen.

## Operatoren

In der reaktiven Entwicklung mit Reactor sind Operatoren Funktionen oder Methoden,
die auf `Flux`- oder `Mono`-Objekten angewendet werden, um Transformationen durchzuführen,
Datenströme zu manipulieren oder bestimmte Operationen auf den Daten auszuführen.
Operatoren erweitern die Funktionalität von `Flux` und `Mono` und ermöglichen eine flexible Handhabung von reaktiven Datenströmen.
Ein Beispiel für einen Operator in Reactor ist der `map`-Operator. Dieser Operator wird verwendet,
um jeden Wert in einem `Flux` oder `Mono` zu transformieren. Hier ist ein einfaches Beispiel:

```java
import reactor.core.publisher.Flux;

public class ReactorMapExample {
    public static void main(String[] args) {
        // Creating a simple flux of integers
        Flux<Integer> numbers = Flux.just(1, 2, 3, 4, 5);

        // Applying the map operator to square each value
        Flux<Integer> squaredNumbers = numbers.map(x -> x * x);

        // Subscribing the transformed flux
        squaredNumbers.subscribe(System.out::println);
    }
}
```

In diesem Beispiel wird ein `Flux` von Ganzzahlen erstellt und der `map`-Operator wird verwendet, um jeden Wert im `Flux` zu quadrieren.
Das Ergebnis ist ein neuer `Flux` mit den quadrierten Werten. Wenn dieses Programm ausgeführt wird, wird folgende Ausgabe erzeugt,
welche die quadrierten Werte der ursprünglichen Zahlen darstellt.

```
1
4
9
16
25
```

Operatoren wie `map` spielen eine entscheidende Rolle in der reaktiven Programmierung mit Reactor, da sie die
Transformation und Modifikation von reaktiven Datenströmen ermöglichen. Dies verleiht der reaktiven Programmierung
eine beeindruckende Flexibilität und Leistungsfähigkeit. Neben `map` gibt es eine Vielzahl weiterer Operatoren,
die spezifische Anforderungen adressieren und die Funktionalität erweitern.
Die Anwendung von Operatoren wie `filter` ermöglicht beispielsweise die selektive Auswahl von Datenpunkten in einem Datenstrom.
Hier kommt die Idee der funktionalen Programmierung ins Spiel, bei der die Verwendung von Lambda-Funktionen eine wichtige Rolle spielt.
Lambda-Funktionen ermöglichen es, Funktionen als Parameter zu übergeben, was besonders in reaktiven Programmierparadigmen nützlich ist.
Sie bieten nicht nur einen eleganten Weg, um Code zu strukturieren, sondern tragen auch dazu bei, Seiteneffekte zu minimieren und den
Code reiner und leichter wartbar zu machen.
Ein weiterer bedeutender Operator ist `flatMap`, der es erlaubt, aus einem Datenpunkt einen neuen reaktiven Datenstrom zu erzeugen.
Dies ist besonders nützlich, um komplexe Operationen auf den Daten durchzuführen oder um Daten aus verschiedenen Quellen zu kombinieren.
Das Zusammenführen von verschiedenen Datenströmen kann unter anderem mithilfe des `merge`-Operators erreicht werden.
Die Verwendung dieser Operatoren in Verbindung mit funktionaler Programmierung und Lambda-Funktionen ermöglicht es,
Datenströme auf eine klare und effiziente Weise zu transformieren, ohne dabei die Lesbarkeit und Wartbarkeit des Codes zu beeinträchtigen.
Dadurch wird die reaktive Programmierung mit Reactor nicht nur leistungsstark, sondern auch flexibel und gut strukturiert.

## Scheduler

Schedulers in Reactor ermöglichen die Steuerung der Ausführung von Code auf verschiedenen Threads.
Dies ist wichtig für die asynchrone Verarbeitung von Operationen und die Vermeidung von Blockierungen.
Es gibt verschiedene `Scheduler`-Typen in Reactor, darunter:

- `Schedulers.immediate()`: Führt den Code auf dem aktuellen Thread aus.
- `Schedulers.single()`: Führt den Code auf einem einzigen Hintergrundthread aus.
- `Schedulers.parallel()`: Verwendet einen Pool von Hintergrundthreads für parallele Ausführung.
- `Schedulers.elastic()`: Passt die Anzahl der Hintergrundthreads je nach Bedarf an.

## Backpressure

Reactor berücksichtigt das Konzept des Backpressure, bei dem `Subscriber` den Datenfluss steuern können, um Überlastung zu vermeiden.
Dies ermöglicht eine effiziente Verarbeitung, auch wenn die Produktion von Daten schneller ist als die Verarbeitung.

## Event Loop (Reaktor)

Die Event Loop in Reactor ist ein zentraler Mechanismus, der auf einem Thread läuft
und kontinuierlich auf Ereignisse (Daten, Signale) wartet. Wenn ein Ereignis eintritt,
wird die zugehörige Operation ausgeführt, wobei der Hauptthread nicht blockiert wird.

[^1]:
    https://www.computerweekly.com/de/definition/Reaktive-Programmierung, Computer Weekly Mai 2021,
    letzter Zugriff am 09.09.23

[^2]:
    Die Reaktiven Prinzipien, 16. September 2014, Jonas Bonér https://www.reactiveprinciples.org/principles/index.html,
    letzter Zugriff am 09.09.2023

[^3]:
    RX Marbels, https://rxmarbles.com/#merge,
    letzter Zugriff am 12.09.2023

[^4]:
    https://jax.de/blog/die-untiefen-reaktiver-programmierung/, Die Untiefen reaktiver Programmierung, 22. Februar 2022,
    letzter Zugriff am 11.09.2023

[^5]:
    https://projectreactor.io/docs/core/release/api/, reactor-core 3.5.9,
    letzter Zugriff am 11.09.2023

[^6]:
    https://projectreactor.io/, Project Reactor,
    letzter Zugriff 11.09.2023

[^7]:
    https://projectreactor.io/docs/core/release/reference/#getting-started, Reactor 3 Reference Guide,
    letzter Zugriff am 11.09.2023

[^8]:
    https://r2dbc.io/, R2DBC,
    letzter Zugriff am 11.09.2023

[^9]:
    https://entago.ch/wp-content/uploads/2020/09/Reaktive-Programmierung-in-Java.pdf, Reaktive Programmierung in Java (Reactive Programming),
    letzter Zugriff am 11.09.2023
