---
authorName: Alexander Euler
authorGithubName: aleeexx
---

# RabbitMQ

## Abh√§ngigkeiten

Bei Kommunikation innerhalb einer Anwendung mit beispielsweise RabbitMQ - z.B. zwischen
verschiedenen Microservices - so kann das `spring-boot-starter-stream-rabbit`-Starterpaket verwendet.

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-stream-rabbit</artifactId>
</dependency>

<!-- Alternatively, you can use the less optionated amqp starter -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-amqp</artifactId>
</dependency>
```

Soll die reaktive Variante der Kommunikation mit RabbitMQ verwendet werden, so kann das
`spring-cloud-starter-stream-rabbit`-Starterpaket verwendet werden.

```xml
<groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-amqp</artifactId>
</dependency>

<dependency>
    <groupId>io.projectreactor.rabbitmq</groupId>
    <artifactId>reactor-rabbitmq</artifactId>
</dependency>
```

## Konfiguration

## Verwendung

Sender vorher:

```java
@Component
public class EventPublisherImpl implements EventPublisher {
    private StreamBridge streamBridge;

    @Autowired
    public EventPublisherImpl(StreamBridge streamBridge) {
        this.streamBridge = streamBridge;
    }

    @Override
    @Transactional
    public boolean publishEvent(UserRegisteredEvent event) {
        var successfullyPublished = streamBridge.send("eventPublisher-out-0", event);
        if (!successfullyPublished) {
            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
        }

        return successfullyPublished;
   }
}
```

Consumer vorher:

```java
@Component
public class EventConsumer implements Consumer<Message<UserRegisteredEvent>> {
    @Override
    @Transactional
    public void accept(Message<UserRegisteredEvent> message) {
        var userRegisteredEvent = message.getPayload();

        // ...
    }
}

```

Sender nachher:

```java
@Component
public class EventPublisherImpl {
    private final Sender sender;
    private String queueName = "demo-queue";

    @Autowired
    EventPublisherImpl(Sender sender) {
        this.sender = sender;
    }

    public Mono<User> sendMessage(User user, String inviteCode) {
        UserRegisteredEvent event = new UserRegisteredEvent(user, inviteCode);
        try {
            ObjectMapper objectMapper = new ObjectMapper();
            byte[] eventBytes = objectMapper.writeValueAsBytes(event);

            Mono<OutboundMessage> outboundMono = Mono.just(new OutboundMessage(
                "",
                queueName,
                eventBytes
            ));
            return sender
                .send(outboundMono)
                .doOnTerminate(() -> {
                    // ...
                })
                .thenReturn(user);
        } catch (Exception e) {
            return Mono.error(e);
        }
    }
}
```

Consumer nachher:

```java
@Configuration
@EnableRabbit
public class EventConsumer {
    @RabbitListener(queues = "demo-queue")
    public Mono<Void> handleMessage(Message<byte[]> message) {
        try {
            byte[] userRegisteredEventByteArray = message.getPayload();

            ObjectMapper objectMapper = new ObjectMapper();
            UserRegisteredEvent userRegisteredEvent = objectMapper.readValue(
                userRegisteredEventByteArray,
                UserRegisteredEvent.class
            );

            // ...

        } catch (Exception e) {}

        return Mono.empty();
    }
}
```
